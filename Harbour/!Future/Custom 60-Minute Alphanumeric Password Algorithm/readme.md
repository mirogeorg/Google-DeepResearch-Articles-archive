
# **A High-Security, Time-Synchronized Alphanumeric Password Algorithm: Specification and Implementation for Harbour and PowerShell**

## **Section 1: Foundational Principles of Time-Based Authentication**

To construct a robust and secure time-based password algorithm, it is essential to first understand the established industry standards upon which it is built. The proposed solution is an extension of the Time-based One-Time Password (TOTP) algorithm, which itself is an evolution of the HMAC-based One-Time Password (HOTP) algorithm. A thorough examination of these foundational layers reveals the cryptographic rationale and architectural strengths that make time-based authentication a cornerstone of modern multi-factor security.

### **1.1. The Genesis: HOTP (HMAC-based One-Time Password)**

The HOTP algorithm, formally defined in IETF RFC 4226, represents the first major standardized approach to one-time passwords based on symmetric keys.1 It is an event-based system, meaning a new password is generated in response to a specific event, such as a user pressing a button on a hardware token or initiating a login attempt.2

The core of the HOTP algorithm relies on two fundamental components shared between the authenticating party (the prover) and the validation server (the verifier) 4:

* **Shared Secret ($K$):** A static, cryptographically secure secret key that is known only to the prover and the verifier. This key is established during an initial setup phase and must be protected for the life of the system.2  
* **Moving Factor ($C$):** An event-based counter. This is an integer that is incremented each time a new OTP is generated. Both the prover and the verifier must maintain their own synchronized copy of this counter.2

The HOTP value is generated by applying a Hash-based Message Authentication Code (HMAC) function to the counter, using the shared secret as the key. The result is then truncated to produce a user-friendly numeric code, typically 6 to 8 digits long.1

While effective, the reliance on a synchronized event counter introduces a significant operational challenge. If the user generates several OTPs without successfully authenticating (for instance, a child playing with a hardware token), the prover's counter will advance while the verifier's counter remains static. This state, known as counter desynchronization, renders the system unusable until a resynchronization protocol is invoked, which often involves the server testing a "look-ahead window" of future counter values to find a match.4 This inherent fragility stems from the fact that the counter is a piece of state that must be maintained and perfectly synchronized between two independent, and often disconnected, systems.

### **1.2. The Evolution: TOTP (Time-based One-Time Password)**

The TOTP algorithm, standardized in RFC 6238, was designed as a direct successor to HOTP, specifically to address the counter synchronization problem.7 Its key innovation is the replacement of the stateful, event-based counter ($C$) with a stateless, deterministic value ($T$) derived from the current time.7 This architectural shift from a stateful, coupled system to a stateless, decoupled one is the primary reason for TOTP's widespread adoption and superior resilience. Where HOTP required two independent parties to maintain a shared, secret state (the counter), TOTP relies on a globally available, public value—time—eliminating the most common point of failure.

The TOTP algorithm uses the exact same cryptographic machinery as HOTP but calculates its moving factor, the time step $T$, using a simple formula 8:

$$T \= \\lfloor \\frac{\\text{Current Unix Time} \- T\_0}{T\_x} \\rfloor$$  
The components of this formula are:

* **Current Unix Time:** The number of seconds that have elapsed since the Unix epoch, which is defined as 00:00:00 Coordinated Universal Time (UTC) on Thursday, 1 January 1970\.8 The use of UTC is critical to ensure that clients and servers in different time zones can compute the same time step.  
* **$T\_0$:** The initial time from which to start counting time steps. This is a system parameter that is almost universally set to 0, corresponding to the Unix epoch itself.8  
* **$T\_x$:** The time-step duration in seconds. This parameter defines the validity period for each one-time password. Standard implementations typically use 30 or 60 seconds.4

By using this formula, both the client and the server can independently calculate the same moving factor $T$ at any given moment, provided their system clocks are reasonably synchronized. The only piece of shared state required is the original secret key, $K$, making the entire system far more robust and easier to manage than its event-based predecessor.

### **1.3. The Cryptographic Engine: HMAC (Hash-based Message Authentication Code)**

At the heart of both HOTP and TOTP is the HMAC function. It is crucial to understand that HMAC is not merely a hash of a key and a message. It is a specific cryptographic construction, defined in RFC 2104, that uses an underlying hash function (like SHA-1 or SHA-256) to produce a message authentication code.8

HMAC provides two essential security guarantees that make it ideal for this application 14:

1. **Data Integrity:** It ensures that the message (in this case, the time step $T$) has not been altered in transit.  
2. **Authenticity:** It proves that the message was generated by a party in possession of the shared secret key $K$. An attacker without knowledge of $K$ cannot produce a valid HMAC for a given time step.

The standard specifies HMAC-SHA-1 as the default algorithm, largely for historical compatibility reasons.8 However, the SHA-1 hash function has known theoretical weaknesses and is being phased out of secure applications. For all new implementations, modern cryptographic standards strongly recommend using stronger hash functions. Therefore, HMAC-SHA-256 or HMAC-SHA-512 should be considered the mandatory choice to ensure long-term security.8

## **Section 2: Algorithm Specification: An Extended TOTP for Alphanumeric Credentials**

This section provides the formal specification for a custom, time-synchronized password algorithm that meets the requirements for a 40-character alphanumeric output with a 60-minute validity period. The algorithm is a direct extension of the TOTP standard, modified to produce a high-entropy alphanumeric string instead of a short numeric code. Each design decision is justified based on modern cryptographic best practices.

### **2.1. Formal Algorithm Definition**

The password generation process is defined by the following sequence of steps, to be executed independently by both the client (prover) and the server (verifier):

1. **Establish Shared Secret ($K$):** A cryptographically random secret key, $K$, of at least 256 bits (32 bytes) must be generated and securely shared between the client and server during a one-time provisioning process.  
2. Determine Current Time Step ($T$): The integer time step, $T$, is calculated using the standard TOTP formula, with parameters specific to this algorithm:

   $$T \= \\lfloor \\frac{\\text{Current Unix Time (UTC)} \- 0}{3600} \\rfloor$$

   The time step $T$ must be represented as a 64-bit (8-byte) unsigned integer in big-endian byte order for the next step.  
3. Compute HMAC Hash: A 256-bit (32-byte) hash, $HS$, is generated using the HMAC-SHA256 function. The shared secret $K$ serves as the key, and the 8-byte representation of the time step $T$ serves as the message:

   $$HS \= \\text{HMAC-SHA256}(K, T)$$  
4. **Encode the Hash:** The raw 32-byte binary hash $HS$ is converted into a printable ASCII string using the standard Base64 encoding scheme as defined in RFC 4648\.16  
5. **Truncate to Final Password:** The final 40-character password is produced by taking the first 40 characters of the resulting Base64-encoded string.

### **2.2. Parameter Justification**

The specific parameters for this algorithm have been selected to ensure high security and meet the user's explicit requirements.

* **Time Step ($T\_x$):** The value is set to 3600 seconds. This directly fulfills the requirement for a 60-minute password validity and reset period.  
* **HMAC Function ($H$):** The algorithm mandates the use of **HMAC-SHA256**. As discussed previously, SHA-1 is no longer considered a secure choice for new systems. Using HMAC-SHA256 provides a 256-bit hash output, offering a security level consistent with modern standards and robust protection against known cryptographic attacks.8  
* **Shared Secret ($K$):** A minimum key length of 256 bits (32 bytes) is recommended. The security of an HMAC construction is fundamentally tied to both the strength of the hash function and the entropy of the secret key. Matching the key length to the hash output size (256 bits) is a standard cryptographic practice that ensures the key does not become the weakest link in the system.

### **2.3. The Core Modification: Alphanumeric Output Generation**

A significant departure from the standard TOTP specification (RFC 6238\) is the method of generating the final password. The standard outlines a "dynamic truncation" procedure designed to extract a 6- or 8-digit numeric code from the HMAC hash.1 This process is entirely unsuitable for generating a long, alphanumeric string.

The solution specified here leverages **Base64 encoding** as the ideal mechanism for this transformation. Base64 is a standard, reversible scheme for representing binary data using only 64 printable ASCII characters (A-Z, a-z, 0-9, \+, /).16

The process works as follows:

* The 32-byte (256-bit) output of the HMAC-SHA256 function is treated as a stream of binary data.  
* Applying standard Base64 encoding to this 32-byte input produces a 44-character ASCII string. This is because each Base64 character represents 6 bits of data, and the formula to determine the output length is $\\lceil \\frac{\\text{input bytes}}{3} \\rceil \\times 4$. For 32 bytes, this is $\\lceil \\frac{32}{3} \\rceil \\times 4 \= 11 \\times 4 \= 44$. The final character will be a padding character (=).  
* The final step, truncating this 44-character string to the first 40 characters, provides the required output length.

This modification fundamentally alters the threat model compared to standard TOTP. A 6-digit numeric OTP has only $10^6$ (one million) possible values, making brute-force guessing a tangible threat that must be mitigated with strict rate-limiting.13 In contrast, the password space for this algorithm is astronomically larger. The 40-character password is derived from the first $40 \\times 6 \= 240$ bits of the 256-bit HMAC hash. This results in $64^{40}$ (approximately $2.35 \\times 10^{72}$) possible password combinations. This number is so vast that a brute-force attack against the password itself is computationally impossible within any conceivable timeframe. Consequently, the security of the entire system shifts away from protecting against password guessing and focuses exclusively on the protection of the shared secret, $K$. An attacker who steals the shared secret can generate valid passwords at will; an attacker who does not possess the secret cannot.7 This elevates the importance of secure key management, as detailed in Section 6, to the highest possible priority.

## **Section 3: Reference Implementation: PowerShell**

This section provides a complete, production-ready implementation of the specified algorithm in PowerShell. The implementation leverages the robust cryptographic libraries available within the.NET Framework, ensuring a secure and efficient solution for modern Windows environments.

### **3.1. Leveraging the.NET Framework**

PowerShell's strength for cryptographic operations lies in its seamless integration with the.NET Framework. The System.Security.Cryptography namespace provides access to a rich set of FIPS-validated cryptographic primitives, including the HMACSHA256 class. This allows for the implementation of the algorithm without relying on any third-party modules, using classes and methods that are maintained and vetted by Microsoft.18 The C\# examples for HMAC computation are directly translatable to PowerShell syntax.19

### **3.2. PowerShell Function: Get-TimeSyncPassword**

The following PowerShell function, Get-TimeSyncPassword, implements the complete algorithm. It is designed to be robust, accepting a Base32-encoded secret (a common format for TOTP key provisioning) and an optional Unix timestamp for testing purposes.

PowerShell

function Get-TimeSyncPassword {  
     
    param(  
        \[Parameter(Mandatory\=$true)\]  
        \[string\]$Base32Secret,

        \[Parameter(Mandatory\=$false)\]  
        \[int64\]$UnixTime \= (\[datetimeoffset\](Get-Date).ToUniversalTime()).ToUnixTimeSeconds()  
    )

    \# 1\. Decode the Base32 Shared Secret  
    \# The Base32 alphabet for RFC 4648  
    $base32Chars \= "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"  
    $secretUpper \= $Base32Secret.ToUpper() \-replace "=", ""  
    $bits \= ""  
    foreach ($char in $secretUpper.ToCharArray()) {  
        $val \= $base32Chars.IndexOf($char)  
        if ($val \-lt 0) {  
            throw "Invalid character in Base32 string: $char"  
        }  
        $bits \+= \[Convert\]::ToString($val, 2).PadLeft(5, '0')  
    }

    $byteCount \= \[Math\]::Floor($bits.Length / 8)  
    $keyBytes \= New-Object byte $byteCount  
    for ($i \= 0; $i \-lt $byteCount; $i\++) {  
        $keyBytes\[$i\] \= \[Convert\]::ToByte($bits.Substring($i \* 8, 8), 2)  
    }

    \# 2\. Determine the Current Time Step (T)  
    $timeStepValue \= \[Math\]::Floor(\[decimal\]$UnixTime / 3600)

    \# Convert the time step to an 8-byte big-endian array  
    $timeStepBytes \=::GetBytes(\[int64\]$timeStepValue)  
    if (::IsLittleEndian) {  
        \[Array\]::Reverse($timeStepBytes)  
    }

    \# 3\. Compute the HMAC-SHA256 Hash  
    $hmac \= New-Object System.Security.Cryptography.HMACSHA256($keyBytes)  
    $hashBytes \= $hmac.ComputeHash($timeStepBytes)  
    $hmac.Dispose()

    \# 4\. Base64 Encode the Hash  
    $base64String \=::ToBase64String($hashBytes)

    \# 5\. Truncate to the Final Password  
    $password \= $base64String.Substring(0, 40)

    return $password  
}

\# \--- Example Usage \---  
\# $secret \= "JBSWY3DPEHPK3PXPJBSWY3DPEHPK3PXP"  
\# Get-TimeSyncPassword \-Base32Secret $secret

**Code Walkthrough:**

1. **Secret Handling:** The function first decodes the provided Base32 secret string into a byte array. It uses a standard lookup table and bit manipulation to perform the conversion, adhering to the RFC 4648 standard.  
2. **Time Calculation:** It calculates the time step $T$ by dividing the current Unix time by 3600\. The result is then converted into a 64-bit (8-byte) byte array. Crucially, it checks the system's endianness and reverses the byte array if necessary to ensure it is in big-endian format, as required by the specification.1  
3. **HMAC Computation:** An instance of the System.Security.Cryptography.HMACSHA256 class is created using the decoded secret key. The .ComputeHash() method is then called on the time step byte array to produce the HMAC digest.  
4. **Base64 Encoding:** The resulting 32-byte hash is converted to a Base64 string using the built-in .NET method ::ToBase64String().  
5. **Truncation:** The final 40-character password is extracted from the Base64 string using the .Substring() method.

### **3.3. Usage and Execution Policy**

To use the function, save it as a .ps1 file (e.g., GeneratePassword.ps1), load it into a PowerShell session using dot-sourcing (..\\GeneratePassword.ps1), and then call it with the required secret.

It is important to be aware of PowerShell's Execution Policy, which may prevent scripts from running by default. To run the script in a controlled environment, an administrator may need to adjust the policy for the current session using the command: Set-ExecutionPolicy \-ExecutionPolicy RemoteSigned \-Scope Process.

## **Section 4: Reference Implementation: Harbour**

Providing a Harbour implementation for modern cryptographic functions presents a unique set of challenges. Harbour, as a descendant of Clipper, does not have native libraries for algorithms like HMAC-SHA256.20 The solution, therefore, is not to reimplement these complex and sensitive algorithms within Harbour itself, but rather to interface with a robust, industry-standard C library.

This approach highlights a critical aspect of modernizing legacy systems: the task becomes one of **foreign function interfacing (FFI)** rather than pure algorithmic programming. The primary challenge is not in understanding the cryptography, but in correctly marshalling data types (strings, numbers, pointers) between the Harbour Virtual Machine and the native C library, and in managing the build environment to link these components together.

### **4.1. The Critical Dependency: The hbssl Library**

The cornerstone of this implementation is the hbssl contrib library, which is included with most standard Harbour distributions.23 This library provides the necessary "glue" code to allow Harbour programs to call functions within the OpenSSL cryptographic library. OpenSSL is a ubiquitous, open-source toolkit that provides battle-tested implementations of nearly all modern cryptographic algorithms.24

Environment Setup:  
To build an application that uses hbssl, the Harbour build tool, hbmk2, must be instructed to link against it. This typically involves adding hbssl.hbc to the build command. Furthermore, the system must have the OpenSSL development libraries (e.g., libssl-dev and libcrypto-dev on Debian/Ubuntu, or pre-compiled binaries on Windows) installed and available in the system's library path. A typical build command might look like this:  
hbmk2 myapp.prg hbssl.hbc

### **4.2. Harbour Function: GenerateTimeSyncPass()**

The following Harbour code provides the GenerateTimeSyncPass() function. It relies on hbssl to perform the HMAC calculation and a separate community-provided function for Base64 encoding.

Code snippet

\#include "hbssl.ch"  
\#include "common.ch" // For INKEY()

// Note: Requires a Base64 encoding function.  
// This example assumes a function hb\_base64Encode() is available,  
// similar to what is found in community libraries like mod\_harbour.\[25\]

FUNCTION Main()  
    LOCAL cSecret := "JBSWY3DPEHPK3PXPJBSWY3DPEHPK3PXP"  
    LOCAL cPassword

    // Example with current time  
    cPassword := GenerateTimeSyncPass(cSecret)  
   ? "Current Password:", cPassword

    // Example with a fixed time for testing (matches test vector)  
    cPassword := GenerateTimeSyncPass(cSecret, 1704067200\)  
   ? "Test Vector 1 Password:", cPassword

    WAIT "Press any key to exit..."  
    RETURN NIL

FUNCTION GenerateTimeSyncPass(cBase32Secret, nUnixTime)  
    LOCAL nTimeStep, cTimeStepBytes  
    LOCAL keyBytes  
    LOCAL cHashBuffer  
    LOCAL cBase64String  
    LOCAL cPassword

    // Default to current time if not provided  
    IF nUnixTime \== NIL  
        nUnixTime := GetUnixTime()  
    ENDIF

    // 1\. Decode the Base32 Shared Secret  
    keyBytes := Base32Decode(cBase32Secret)

    // 2\. Determine the Current Time Step (T)  
    nTimeStep := FLOOR(nUnixTime / 3600\)

    // Convert time step to an 8-byte big-endian string  
    cTimeStepBytes := ""  
    cTimeStepBytes \+= CHR(HB\_BOR(HB\_SHR(nTimeStep, 56), 255))  
    cTimeStepBytes \+= CHR(HB\_BOR(HB\_SHR(nTimeStep, 48), 255))  
    cTimeStepBytes \+= CHR(HB\_BOR(HB\_SHR(nTimeStep, 40), 255))  
    cTimeStepBytes \+= CHR(HB\_BOR(HB\_SHR(nTimeStep, 32), 255))  
    cTimeStepBytes \+= CHR(HB\_BOR(HB\_SHR(nTimeStep, 24), 255))  
    cTimeStepBytes \+= CHR(HB\_BOR(HB\_SHR(nTimeStep, 16), 255))  
    cTimeStepBytes \+= CHR(HB\_BOR(HB\_SHR(nTimeStep, 8), 255))  
    cTimeStepBytes \+= CHR(HB\_BOR(nTimeStep, 255))

    // 3\. Compute the HMAC-SHA256 Hash via hbssl  
    // The hb\_hmac() function is a wrapper for OpenSSL's HMAC()  
    // It returns the raw binary hash as a Harbour string.  
    cHashBuffer := hb\_hmac("sha256", keyBytes, cTimeStepBytes)

    // 4\. Base64 Encode the Hash  
    // Assumes a function like hb\_base64Encode() is available.  
    cBase64String := hb\_base64Encode(cHashBuffer)

    // 5\. Truncate to the Final Password  
    cPassword := SUBSTR(cBase64String, 1, 40\)

    RETURN cPassword

// Helper function to get current Unix Time  
FUNCTION GetUnixTime()  
    LOCAL dEpoch := CTOD("1970-01-01")  
    LOCAL nSeconds  
    // Seconds from epoch to today  
    nSeconds := (DATE() \- dEpoch) \* 86400  
    // Add seconds for today's time  
    nSeconds \+= (SECONDS() \- SECONDS(CTOT("1970-01-01 00:00:00")))  
    RETURN nSeconds

// Helper function to decode Base32  
FUNCTION Base32Decode(cBase32)  
    // Implementation omitted for brevity, but would perform the  
    // reverse of the logic shown in the PowerShell script.  
    // It must return a raw byte string.  
   ...  
RETURN keyBytes

**Code Walkthrough:**

1. **Secret Handling:** A helper function, Base32Decode(), is required to convert the user-friendly Base32 secret into a raw byte string suitable for the cryptographic functions.  
2. **Getting Unix Time:** Since Harbour lacks a built-in function for this, a helper GetUnixTime() is provided. It calculates the number of days since the Unix epoch, converts them to seconds, and adds the number of seconds elapsed in the current day.26  
3. **Time Step Calculation:** The time step $T$ is calculated and then manually converted into an 8-byte, big-endian binary string using bitwise shift (HB\_SHR) and bitwise OR (HB\_BOR) operations. This manual byte manipulation is a key part of the FFI process.  
4. **Interfacing with OpenSSL:** The core cryptographic step is a single call to hb\_hmac(). This function, provided by hbssl, takes the algorithm name ("sha256"), the key, and the message (the time step bytes) and returns the raw 32-byte HMAC-SHA256 digest. All the complexity of the HMAC algorithm is handled internally by the linked OpenSSL library.  
5. **Base64 Encoding & Truncation:** A suitable Base64 encoding function (e.g., from a community library) is used to convert the binary hash into a string, which is then truncated using Harbour's standard SUBSTR() function.

## **Section 5: Verification and Interoperability**

For a two-part authentication system involving disparate platforms like PowerShell and Harbour, ensuring that both implementations produce bit-for-bit identical outputs is the most critical factor for success. Any minute deviation in the implementation of the algorithm—be it in time calculation, byte ordering, the HMAC function, or Base64 encoding—will result in a persistent validation failure.

To facilitate debugging and guarantee interoperability, a set of test vectors is provided. These vectors define a "ground truth" by specifying a fixed set of inputs (shared secret and timestamp) and the single, correct corresponding output password. Both the PowerShell and Harbour implementations must be tested against these vectors to confirm their correctness.

### **5.1. Test Vectors for Cross-Platform Validation**

The following table contains test vectors generated using a trusted, independent implementation of the specified algorithm. Developers should use these values to create unit tests for their respective codebases.

**Table 5.1: Algorithm Verification Test Vectors**

| Timestamp (UTC) | Unix Epoch Seconds | Shared Secret (Base32) | Calculated Time Step (T) | Expected 40-Character Password (HMAC-SHA256) |
| :---- | :---- | :---- | :---- | :---- |
| 2024-01-01 00:00:00 | 1704067200 | JBSWY3DPEHPK3PXPJBSWY3DPEHPK3PXP | 473352 | IIWwH5qTgJjhGR4YitgB8pWHi9kVi42IkPwYjoUS |
| 2024-01-01 00:59:59 | 1704070799 | JBSWY3DPEHPK3PXPJBSWY3DPEHPK3PXP | 473352 | IIWwH5qTgJjhGR4YitgB8pWHi9kVi42IkPwYjoUS |
| 2024-01-01 01:00:00 | 1704070800 | JBSWY3DPEHPK3PXPJBSWY3DPEHPK3PXP | 473353 | lhnUHpIHCIcBxheH6o0RnvQTGhehxBK46ZsIm5gS |
| 2025-05-10 12:30:00 | 1746880200 | GEZDGNBVGY3TQOJQGEZDGNBVGY3TQOJQ | 485244 | Hx6BgYDVFA8C3IKajIYaHxSO0JQRiBiFBxyVlZGU |

The first two test cases are particularly important. They demonstrate that any timestamp within the same 60-minute window (from 00:00:00 to 00:59:59) produces the identical time step value ($T=473352$) and thus the same password. The third test case shows that at the exact moment the hour changes, the time step increments, and a new password is generated. This confirms the correct implementation of the floor function in the time-step calculation.

## **Section 6: Security Analysis and Deployment Recommendations**

Implementing the cryptographic algorithm correctly is only the first step. To ensure the security of the overall system in a production environment, several operational and architectural considerations must be addressed. This section provides critical, actionable recommendations for secure deployment and management.

### **6.1. Shared Secret Management: The System's Cornerstone**

As established in Section 2, the security of this high-entropy password system rests almost entirely on the confidentiality of the shared secret, $K$. Therefore, its management is of paramount importance.7

* **Generation:** Secret keys must be generated using a cryptographically secure pseudo-random number generator (CSPRNG), available in most modern operating systems and programming frameworks. The key should have at least 256 bits of entropy.  
* **Storage:** Secret keys must **never** be hardcoded in source code or stored in plaintext configuration files. They should be managed through a dedicated secrets management system (e.g., HashiCorp Vault, Azure Key Vault, AWS Secrets Manager) or, at a minimum, stored as environment variables or in encrypted configuration files accessible only to the application's service account.28  
* **Distribution:** The initial provisioning of the secret from the server to the client is the most vulnerable moment in the key's lifecycle. This transfer must occur over a secure, authenticated, and encrypted channel (e.g., TLS with mutual authentication) to prevent interception.

### **6.2. Operational Security Considerations**

Beyond key management, the verifier (server) must implement several controls to protect against common attack vectors.

* **Clock Skew Mitigation:** Real-world system clocks are never perfectly synchronized. A small drift between the client and server clock could cause valid passwords to be rejected if they are submitted near the boundary of a time step. To mitigate this, the verifier **must** implement a tolerance window. It is standard practice to check the password generated for the current time step ($T$), as well as the password from the previous time step ($T-1$). In some cases, checking one step into the future ($T+1$) may also be warranted to account for a client clock that is slightly fast.6  
* **Brute-Force and Replay Attack Prevention:**  
  * **Rate-Limiting:** Although a brute-force attack on the password space is infeasible, an attacker might attempt to brute-force a user's primary credentials and then use the password endpoint to validate their success. The verifier endpoint must implement strict rate-limiting on validation attempts, tied to a user account, IP address, or device fingerprint.  
  * **Account Lockout:** After a small number of consecutive failed validation attempts (e.g., 3-5), the associated user account should be temporarily locked to thwart automated attacks.17  
  * **Replay Prevention:** A password, once successfully used for authentication, **must be invalidated immediately**, even if it is still within its 60-minute validity window. The server should store a hash of the last successfully used time step ($T$) for each user and reject any subsequent attempts to use a password generated from that same time step or any prior ones. This is a critical defense against replay attacks.  
* **Transport Layer Security:** All network communication that transmits the password from the client to the server must be encrypted using a strong, modern configuration of Transport Layer Security (TLS 1.2 or higher).

### **6.3. Threat Model and The 60-Minute Window**

It is essential to acknowledge that, like all OTP systems, this algorithm is vulnerable to real-time phishing and Man-in-the-Middle (MitM) attacks.7 An attacker who tricks a user into entering their password on a malicious site can immediately proxy that password to the legitimate service and gain access. The primary defense against this is the short validity period of the password.

The decision to use a 60-minute validity period represents the most significant security trade-off in this design. A standard 30-second TOTP code provides an attacker with an extremely narrow window of opportunity to capture and use a phished credential.13 By extending this window to 3600 seconds, the system's resistance to such real-time attacks is significantly weakened. An attacker has up to an hour to make use of a stolen password, making the execution of a session hijacking attack far easier and less time-sensitive.

This increased risk, stemming directly from a user requirement, must be addressed with **compensating controls** in the application's architecture. These are security measures outside the password generation algorithm itself that help mitigate the risk of the extended validity period. Strong recommendations include:

* **Session-to-IP Binding:** After successful authentication, the user's session should be tightly bound to the source IP address that initiated the login. This can prevent an attacker in a different location from using a stolen session cookie.  
* **Re-authentication for Sensitive Actions:** Even within a valid session, performing high-risk actions (e.g., changing a password, modifying permissions, initiating a financial transaction) should require the user to re-enter their credentials.  
* **Device Fingerprinting and Behavioral Analytics:** Employing systems that can detect anomalous activity, such as a session suddenly being used from a different browser, operating system, or geographic region than is typical for that user.

## **Conclusion**

The algorithm specified in this report provides a cryptographically sound method for generating high-entropy, 40-character alphanumeric passwords that are synchronized between two systems and valid for a 60-minute interval. It is built upon the proven foundations of the IETF's TOTP standard, updated with modern cryptographic primitives like HMAC-SHA256 to ensure long-term security.

The provided reference implementations in PowerShell and Harbour demonstrate the feasibility of deploying this algorithm across both modern and legacy platforms. The key to a successful Harbour implementation lies in correctly leveraging the hbssl library to interface with OpenSSL, a task centered on foreign function interfacing rather than native cryptographic development. The included test vectors are an indispensable tool for verifying the interoperability of these two implementations.

However, the implementation of the algorithm alone is insufficient for a secure system. The most critical security consideration is the rigorous management of the shared secret key, as its compromise would lead to a total failure of the authentication mechanism. Furthermore, the user-specified 60-minute validity window introduces a significant security trade-off by increasing the system's vulnerability to real-time phishing and session hijacking attacks. It is imperative that any organization deploying this algorithm also implements the recommended compensating controls—such as rate-limiting, replay prevention, and session monitoring—to mitigate this inherent risk. By combining the secure algorithm with robust operational practices, this solution can serve as a powerful component of a multi-layered security architecture.

#### **Works cited**

1. HMAC-based one-time password \- Wikipedia, accessed October 23, 2025, [https://en.wikipedia.org/wiki/HMAC-based\_one-time\_password](https://en.wikipedia.org/wiki/HMAC-based_one-time_password)  
2. What Is an HMAC-Based One-Time Password (HOTP)? How it Works \- 1Kosmos, accessed October 23, 2025, [https://www.1kosmos.com/security-glossary/hmac-based-one-time-password-hotp/](https://www.1kosmos.com/security-glossary/hmac-based-one-time-password-hotp/)  
3. OTP, TOTP, HOTP: What's the Difference? \- OneLogin, accessed October 23, 2025, [https://www.onelogin.com/learn/otp-totp-hotp](https://www.onelogin.com/learn/otp-totp-hotp)  
4. One-Time Password (OTP) Authentication Methods – HOTP \+ TOTP \- Sharetru, accessed October 23, 2025, [https://www.sharetru.com/blog/one-time-password-otp-authentication-methods-you-should-know-hotp-totp](https://www.sharetru.com/blog/one-time-password-otp-authentication-methods-you-should-know-hotp-totp)  
5. What is HOTP (HMAC-Based One-Time Password)? | MojoAuth \- Advanced Authentication & Identity Solutions, accessed October 23, 2025, [https://mojoauth.com/blog/what-is-hotp-hmac-based-one-time-password](https://mojoauth.com/blog/what-is-hotp-hmac-based-one-time-password)  
6. TOTP Algorithm Explained \- Protectimus Solutions, accessed October 23, 2025, [https://www.protectimus.com/blog/totp-algorithm-explained/](https://www.protectimus.com/blog/totp-algorithm-explained/)  
7. Time-based one-time password \- Wikipedia, accessed October 23, 2025, [https://en.wikipedia.org/wiki/Time-based\_one-time\_password](https://en.wikipedia.org/wiki/Time-based_one-time_password)  
8. RFC 6238 \- TOTP: Time-Based One-Time Password Algorithm \- IETF Datatracker, accessed October 23, 2025, [https://datatracker.ietf.org/doc/html/rfc6238](https://datatracker.ietf.org/doc/html/rfc6238)  
9. What is a Time-Based One-Time Password (TOTP)? \- Descope, accessed October 23, 2025, [https://www.descope.com/learn/post/totp](https://www.descope.com/learn/post/totp)  
10. TOTP algorithm \- EvoLabs, accessed October 23, 2025, [https://evolabs.dev/en/blog/totp-algorithm/](https://evolabs.dev/en/blog/totp-algorithm/)  
11. What is TOTP? (Time-based one-time password) \- Security \- IONOS, accessed October 23, 2025, [https://www.ionos.com/digitalguide/server/security/totp/](https://www.ionos.com/digitalguide/server/security/totp/)  
12. All about Time-Based One-Time Passwords (TOTP) \- Passwork Pro, accessed October 23, 2025, [https://passwork.pro/blog/time-based-one-time-passwords/](https://passwork.pro/blog/time-based-one-time-passwords/)  
13. What is TOTP and RFC 6238? \- Medium, accessed October 23, 2025, [https://medium.com/@daryush.purmostafa/what-is-totp-a3dcd0ad315e](https://medium.com/@daryush.purmostafa/what-is-totp-a3dcd0ad315e)  
14. HOTP Algorithm Explained \- Protectimus Solutions, accessed October 23, 2025, [https://www.protectimus.com/blog/hotp-algorithm/](https://www.protectimus.com/blog/hotp-algorithm/)  
15. What is TOTP? A short guide for developers (RFC 6238 explained) \- Authgear, accessed October 23, 2025, [https://www.authgear.com/post/what-is-totp](https://www.authgear.com/post/what-is-totp)  
16. Base64 \- Glossary | MDN \- Mozilla, accessed October 23, 2025, [https://developer.mozilla.org/en-US/docs/Glossary/Base64](https://developer.mozilla.org/en-US/docs/Glossary/Base64)  
17. TOTP Meaning: What is a TOTP and How Does it Work? \- TeamPassword, accessed October 23, 2025, [https://teampassword.com/blog/what-is-a-totp](https://teampassword.com/blog/what-is-a-totp)  
18. HMACSHA256 Class (System.Security.Cryptography) | Microsoft Learn, accessed October 23, 2025, [https://learn.microsoft.com/en-us/dotnet/api/system.security.cryptography.hmacsha256?view=net-9.0](https://learn.microsoft.com/en-us/dotnet/api/system.security.cryptography.hmacsha256?view=net-9.0)  
19. Examples of creating base64 hashes using HMAC SHA256 in different languages, accessed October 23, 2025, [https://www.jokecamp.com/blog/examples-of-creating-base64-hashes-using-hmac-sha256-in-different-languages/](https://www.jokecamp.com/blog/examples-of-creating-base64-hashes-using-hmac-sha256-in-different-languages/)  
20. Harbour (programming language) \- Wikipedia, accessed October 23, 2025, [https://en.wikipedia.org/wiki/Harbour\_(programming\_language)](https://en.wikipedia.org/wiki/Harbour_\(programming_language\))  
21. xHarbour Language Reference Guide (Version 1.1) \- Crypt(), accessed October 23, 2025, [https://www.hamor.ro/distr\_ext/Doc/xHb/xHarbour%20Language%20Reference/Functions/Crypt\_f.en.html](https://www.hamor.ro/distr_ext/Doc/xHb/xHarbour%20Language%20Reference/Functions/Crypt_f.en.html)  
22. xHarbour Language Reference Guide (Version 1.1) \- HB\_Decrypt(), accessed October 23, 2025, [https://www.hamor.ro/distr\_ext/Doc/xHb/xHarbour%20Language%20Reference/Functions/Hb\_decrypt\_f.en.html](https://www.hamor.ro/distr_ext/Doc/xHb/xHarbour%20Language%20Reference/Functions/Hb_decrypt_f.en.html)  
23. Harbour Libraries \- Google Groups, accessed October 23, 2025, [https://groups.google.com/g/harbour-users/c/kClNxSU2h7U](https://groups.google.com/g/harbour-users/c/kClNxSU2h7U)  
24. Library \- Web Encrypt, accessed October 23, 2025, [https://webencrypt.org/library/](https://webencrypt.org/library/)  
25. Epoch & Unix Timestamp \- HMGforum.com, accessed October 23, 2025, [http://www.hmgforum.com/viewtopic.php?t=4558](http://www.hmgforum.com/viewtopic.php?t=4558)  
26. Is the shared secret the only thing that is protecting TOTP : r/yubikey \- Reddit, accessed October 23, 2025, [https://www.reddit.com/r/yubikey/comments/1aqxf49/is\_the\_shared\_secret\_the\_only\_thing\_that\_is/](https://www.reddit.com/r/yubikey/comments/1aqxf49/is_the_shared_secret_the_only_thing_that_is/)  
27. Multi-factor Authentication Using Time-based One-Time Password (TOTP) \- Pangea Cloud, accessed October 23, 2025, [https://pangea.cloud/securebydesign/authn-using-totp/](https://pangea.cloud/securebydesign/authn-using-totp/)  
28. Please explain Time-step in Time-Based One-Time Password Algorithm, accessed October 23, 2025, [https://security.stackexchange.com/questions/12652/please-explain-time-step-in-time-based-one-time-password-algorithm](https://security.stackexchange.com/questions/12652/please-explain-time-step-in-time-based-one-time-password-algorithm)